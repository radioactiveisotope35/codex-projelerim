<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>Mini CS: Arena</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(circle at center, #121821, #050608 70%); overflow:hidden; }
    canvas { display:block; }
    #hud { position:absolute; inset:0; pointer-events:none; color:#fff; }
    #info{ position:absolute; top:16px; left:50%; transform:translateX(-50%); font-size:15px; text-align:center; text-shadow:0 0 6px rgba(0,0,0,.7); line-height:1.4; }
    #crosshair{ position:absolute; top:50%; left:50%; width:26px; height:26px; transform:translate(-50%,-50%) scale(1); display:grid; place-items:center; transition:transform .08s ease-out, opacity .12s ease; opacity:.95; }
    #crosshair::before, #crosshair::after{ content:''; position:absolute; background:#fff; opacity:.85; }
    #crosshair::before{ width:2px; height:100%; } #crosshair::after{ width:100%; height:2px; }
    #hitmarker{ position:absolute; top:50%; left:50%; width:36px; height:36px; transform:translate(-50%,-50%) scale(.8); opacity:0; pointer-events:none; }
    #hitmarker::before, #hitmarker::after{ content:''; position:absolute; inset:0; border:2px solid #fff; opacity:.95;
      clip-path: polygon(0 45%, 35% 45%, 35% 0, 65% 0, 65% 45%, 100% 45%, 100% 55%, 65% 55%, 65% 100%, 35% 100%, 35% 55%, 0 55%); }
    .hitmarker--show{ animation: hm .12s ease-out forwards; } @keyframes hm{ from{opacity:.95; transform:translate(-50%,-50%) scale(1)} to{opacity:0; transform:translate(-50%,-50%) scale(1.3)} }
    #scoreboard{ position:absolute; top:16px; left:16px; font-size:20px; display:grid; gap:4px; text-shadow:0 0 6px rgba(0,0,0,.7); }
    #ammo{ position:absolute; bottom:24px; right:28px; font-size:32px; font-weight:600; text-shadow:0 0 10px rgba(0,0,0,.8); }
    #health{ position:absolute; bottom:24px; left:50%; transform:translateX(-50%); width:min(460px,60vw); height:18px; border:2px solid rgba(255,255,255,.4); border-radius:999px; overflow:hidden; background:rgba(255,255,255,.1); }
    #health>span{ display:block; height:100%; width:100%; background:linear-gradient(90deg,#44ff9a,#31bfff); transition:width .2s ease; }
    #roundBanner{ position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:clamp(42px,5vw,72px); font-weight:700; text-align:center; letter-spacing:6px; text-shadow:0 0 14px rgba(0,0,0,.8); display:none; }
    #pickupBanner{ position:absolute; left:50%; bottom:74px; transform:translateX(-50%); font-size:18px; font-weight:600; padding:8px 12px; border-radius:10px; background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.15); opacity:0; transition:opacity .25s ease; pointer-events:none; text-shadow:0 0 8px rgba(0,0,0,.6); }
    .show-pickup{ opacity:1; }
    #difficulty{ position:absolute; right:24px; bottom:90px; font-size:14px; opacity:.85; background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.15); padding:6px 10px; border-radius:8px; }
    #overlay{ position:absolute; inset:0; background:rgba(255,0,0,0); transition:background .2s ease; pointer-events:none; }
    #minimap{ position:absolute; right:24px; top:24px; width:160px; height:160px; border-radius:12px; background:rgba(0,0,0,.35); border:2px solid rgba(255,255,255,.1); }
    #minimap canvas{ width:100%; height:100%; }
    #gameOver{ position:absolute; inset:0; display:grid; place-items:center; font-size:clamp(40px,8vw,90px); font-weight:800; letter-spacing:8px; text-align:center; backdrop-filter:blur(4px); background:rgba(0,0,0,.75); display:none; }
    #gameOver small{ display:block; font-size:clamp(16px,3vw,22px); margin-top:16px; font-weight:400; letter-spacing:normal; }
  </style>
  <script type="importmap">
    { "imports": { "three":"https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/" } }
  </script>
</head>
<body>
  <div id="hud">
    <div id="info">Oynamak için ekrana tıkla.<br/>WASD: Hareket • Fare: Bakış &amp; Ateş • Sağ Tık: Nişan (ADS) • Space: Zıpla • Shift: Koş • R: Şarjör • H: Zorluk</div>
    <div id="crosshair"></div>
    <div id="hitmarker"></div>
    <div id="scoreboard">
      <div id="score">Skor: 0</div>
      <div id="round">Round: 0</div>
      <div id="enemies">Hayatta Kalan Düşman: 0</div>
    </div>
    <div id="ammo">30 / 120</div>
    <div id="health"><span></span></div>
    <div id="roundBanner"></div>
    <div id="pickupBanner"></div>
    <div id="overlay"></div>
    <div id="minimap"><canvas width="200" height="200"></canvas></div>
    <div id="difficulty">Zorluk: Normal</div>
    <div id="gameOver">OYUN BİTTİ<small>Yeniden başlamak için R tuşuna bas.</small></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { applyPatch } from './update/update-001.js';

    const scene = new THREE.Scene();
    const cubeLoader = new THREE.CubeTextureLoader();
    const skyTexture = cubeLoader.setPath('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/skyboxsun25/').load(['px.jpg','nx.jpg','py.jpg','ny.jpg','pz.jpg','nz.jpg']);
    scene.background = skyTexture; scene.fog = new THREE.Fog(0x0b101a, 40, 180);
    const textureLoader = new THREE.TextureLoader();

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, .1, 1000);
    camera.position.set(0,1.6,12);
    const baseFOV = 70, adsFOV = 58, sprintFOV = 78;

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled=true; document.body.appendChild(renderer.domElement);

    const controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());
    const clock = new THREE.Clock();

    const world = { size:120, walls:[], obstacles:[] };
    const movementConfig = { playerWalk:7.5, playerSprintMultiplier:1.5, jumpStrength:9, gravity:28, enemyChase:5.6, enemyPatrol:3.2 };

    const player = { velocity:new THREE.Vector3(), speed:movementConfig.playerWalk, sprintMultiplier:movementConfig.playerSprintMultiplier, jumpStrength:movementConfig.jumpStrength, gravity:movementConfig.gravity, onGround:false, height:1.6, health:100, ammo:30, reserve:120, maxAmmo:30, reserveMax:210, fireCooldown:0, reloadTime:1.6, isReloading:false, alive:true, lastDamagedAt:-Infinity };
    const game = { score:0, round:0, state:'waiting', enemiesRemaining:0, spawnDelay:0, spawnQueue:0, roundStartAt:0 };

    const enemies = [];
    const lootItems = [];

    // Zorluk
    const difficulty = {
      list:['Easy','Normal','Hard'], idx:1,
      get name(){return this.list[this.idx];},
      get params(){
        if(this.idx===0) return { enemyDamage:7, aimSpread:THREE.MathUtils.degToRad(3.2), burstSize:[2,3], restAfterBurst:1.3, firstShotDelay:[0.35,0.55], losRange:42, engage:26, retreat:4, spawnBase:3, spawnScale:1.1 };
        if(this.idx===2) return { enemyDamage:12, aimSpread:THREE.MathUtils.degToRad(1.8), burstSize:[3,4], restAfterBurst:0.7, firstShotDelay:[0.1,0.25], losRange:55, engage:30, retreat:4.5, spawnBase:5, spawnScale:1.6 };
        return { enemyDamage:9, aimSpread:THREE.MathUtils.degToRad(2.5), burstSize:[2,3], restAfterBurst:1.0, firstShotDelay:[0.25,0.45], losRange:48, engage:28, retreat:4, spawnBase:3, spawnScale:1.2 };
      }
    };

    // Lights
    scene.add(new THREE.AmbientLight(0x5a6370,.7));
    const dirLight = new THREE.DirectionalLight(0xd0e4ff,.9);
    dirLight.position.set(35,60,25); dirLight.castShadow=true;
    dirLight.shadow.mapSize.set(2048,2048); dirLight.shadow.camera.near=1; dirLight.shadow.camera.far=220;
    scene.add(dirLight);

    // Floor & grid
    const floorGeo=new THREE.PlaneGeometry(world.size,world.size,20,20); floorGeo.rotateX(-Math.PI/2);
    const floorColorMap=textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg'); floorColorMap.wrapS=floorColorMap.wrapT=THREE.RepeatWrapping; floorColorMap.repeat.set(world.size/6,world.size/6); floorColorMap.colorSpace=THREE.SRGBColorSpace;
    const floorNormalMap=textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Normal.jpg'); floorNormalMap.wrapS=floorNormalMap.wrapT=THREE.RepeatWrapping; floorNormalMap.repeat.copy(floorColorMap.repeat);
    const floorRoughnessMap=textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Roughness.jpg'); floorRoughnessMap.wrapS=floorRoughnessMap.wrapT=THREE.RepeatWrapping; floorRoughnessMap.repeat.copy(floorColorMap.repeat);
    const floorMat=new THREE.MeshStandardMaterial({ map:floorColorMap, normalMap:floorNormalMap, roughnessMap:floorRoughnessMap, metalness:.15, roughness:.9 });
    const floor=new THREE.Mesh(floorGeo,floorMat); floor.receiveShadow=true; scene.add(floor);
    scene.add(new THREE.GridHelper(world.size,24,0x334050,0x1a2530));

    // Walls
    const wallColorMap=textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg'); wallColorMap.wrapS=wallColorMap.wrapT=THREE.RepeatWrapping; wallColorMap.colorSpace=THREE.SRGBColorSpace;
    const wallNormalMap=textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_normal.jpg'); wallNormalMap.wrapS=wallNormalMap.wrapT=THREE.RepeatWrapping;
    const wallRoughnessMap=textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_roughness.jpg'); wallRoughnessMap.wrapS=wallRoughnessMap.wrapT=THREE.RepeatWrapping;
    const baseWallMaterial=new THREE.MeshStandardMaterial({ map:wallColorMap, normalMap:wallNormalMap, roughnessMap:wallRoughnessMap, metalness:.25, roughness:.85 });
    const wallHeight=6, wallThickness=2, arenaSize=world.size/2;
    function createWall(x,z,w,d){ const g=new THREE.BoxGeometry(w,wallHeight,d); const m=baseWallMaterial.clone(); m.map=baseWallMaterial.map.clone(); m.normalMap=baseWallMaterial.normalMap.clone(); m.roughnessMap=baseWallMaterial.roughnessMap.clone(); const rx=Math.max(1,w/6), ry=Math.max(1,wallHeight/2); m.map.repeat.set(rx,ry); m.normalMap.repeat.copy(m.map.repeat); m.roughnessMap.repeat.copy(m.map.repeat); const mesh=new THREE.Mesh(g,m); mesh.position.set(x,wallHeight/2,z); mesh.castShadow=mesh.receiveShadow=true; scene.add(mesh); world.walls.push(mesh); }
    createWall(0,-arenaSize+wallThickness/2,world.size,wallThickness); createWall(0,arenaSize-wallThickness/2,world.size,wallThickness); createWall(-arenaSize+wallThickness/2,0,wallThickness,world.size); createWall(arenaSize-wallThickness/2,0,wallThickness,world.size);

    // Obstacles
    const obstacleMaterial=new THREE.MeshStandardMaterial({ color:0x253246, metalness:.15, roughness:.7 });
    [{x:-18,z:-10},{x:12,z:-15},{x:-8,z:16},{x:18,z:12},{x:0,z:0},{x:-20,z:22},{x:20,z:-22}].forEach(({x,z})=>{
      const h=THREE.MathUtils.randFloat(2.2,4.4), w=THREE.MathUtils.randFloat(4,10), d=THREE.MathUtils.randFloat(3,8);
      const g=new THREE.BoxGeometry(w,h,d); const m=new THREE.Mesh(g, obstacleMaterial.clone());
      m.material.color.offsetHSL(Math.random()*0.05,0,0); m.position.set(x,h/2,z); m.castShadow=m.receiveShadow=true; scene.add(m); world.obstacles.push(m);
    });

    // Enemy visual
    function createEnemyUniformTexture(){ const c=document.createElement('canvas'); c.width=128; c.height=256; const ctx=c.getContext('2d'); const gr=ctx.createLinearGradient(0,0,0,c.height); gr.addColorStop(0,'#18273d'); gr.addColorStop(.4,'#1f3553'); gr.addColorStop(1,'#101c2e'); ctx.fillStyle=gr; ctx.fillRect(0,0,c.width,c.height); ctx.fillStyle='rgba(90,180,255,.3)'; ctx.fillRect(0,c.height*.15,c.width,18); ctx.fillRect(0,c.height*.45,c.width,10); ctx.fillStyle='rgba(12,18,28,.7)'; for(let i=0;i<6;i++) ctx.fillRect(18,24+i*38,c.width-36,6); ctx.fillStyle='rgba(255,255,255,.08)'; ctx.fillRect(0,c.height*.05,c.width,10); ctx.fillRect(0,c.height*.75,c.width,6); return new THREE.CanvasTexture(c); }
    const enemyUniformTexture=createEnemyUniformTexture(); enemyUniformTexture.wrapS=enemyUniformTexture.wrapT=THREE.RepeatWrapping; enemyUniformTexture.colorSpace=THREE.SRGBColorSpace; enemyUniformTexture.needsUpdate=true;
    const enemyMaterialTemplate=new THREE.MeshStandardMaterial({ map:enemyUniformTexture, metalness:.2, roughness:.65, emissive:new THREE.Color(0x050b14), emissiveIntensity:.25 });
    const enemyGeometry=new THREE.CapsuleGeometry(.6,1.2,6,12);

    // Decorative light
    const pointLight=new THREE.PointLight(0x5ab9ff,1.3,65,2); pointLight.position.set(0,4.5,0); scene.add(pointLight);

    // Weapon group + muzzle
    const muzzleFlashTexture=textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sprites/lensflare0_alpha.png'); muzzleFlashTexture.colorSpace=THREE.SRGBColorSpace;
    const muzzleFlash=new THREE.Sprite(new THREE.SpriteMaterial({ map:muzzleFlashTexture, color:0xfff6a8, transparent:true, blending:THREE.AdditiveBlending }));
    muzzleFlash.scale.set(1.6,1.6,1.6); muzzleFlash.center.set(.5,0); muzzleFlash.visible=false; muzzleFlash.position.set(0,0,-.1);
    const weaponGroup=new THREE.Group(); camera.add(weaponGroup); weaponGroup.position.set(.32,-.3,-.55); weaponGroup.rotation.set(-.05,.25,0); weaponGroup.visible=false;
    const muzzleAnchor=new THREE.Object3D(); muzzleAnchor.position.set(.25,-.05,-.9); weaponGroup.add(muzzleAnchor); muzzleAnchor.add(muzzleFlash);

    // UI refs
    const minimapCanvas=document.querySelector('#minimap canvas'); const minimapCtx=minimapCanvas.getContext('2d');
    const scoreEl=document.getElementById('score'); const roundEl=document.getElementById('round'); const enemiesEl=document.getElementById('enemies');
    const ammoEl=document.getElementById('ammo'); const healthBarEl=document.querySelector('#health > span'); const roundBannerEl=document.getElementById('roundBanner');
    const overlayEl=document.getElementById('overlay'); const gameOverEl=document.getElementById('gameOver'); const crosshairEl=document.getElementById('crosshair');
    const hitmarkerEl=document.getElementById('hitmarker'); const pickupBannerEl=document.getElementById('pickupBanner'); const diffEl=document.getElementById('difficulty');

    // Input
    const keyState={};
    document.addEventListener('keydown',e=>{ keyState[e.code]=true;
      if(e.code==='KeyR'){ if(!player.alive) resetGame(); else if(!player.isReloading && player.ammo<player.maxAmmo && player.reserve>0) reloadWeapon(); }
      if(e.code==='KeyH'){ difficulty.idx=(difficulty.idx+1)%difficulty.list.length; diffEl.textContent='Zorluk: '+difficulty.name; }
    });
    document.addEventListener('keyup',e=>{ keyState[e.code]=false; });

    // Mouse buttons
    let shooting=false, aiming=false;
    document.addEventListener('mousedown',e=>{ if(e.button===0) shooting=true; if(e.button===2) aiming=true; });
    document.addEventListener('mouseup',e=>{ if(e.button===0) shooting=false; if(e.button===2) aiming=false; });
    document.addEventListener('contextmenu', e=> e.preventDefault()); // sağ tık menüsünü kapat

    renderer.domElement.addEventListener('click',()=>{ if(!player.alive) return; controls.lock(); });
    let initialLockHandled=false;
    controls.addEventListener('lock',()=>{ crosshairEl.style.display='block'; document.getElementById('info').style.display='none'; weaponGroup.visible=true; if(!initialLockHandled && game.state==='waiting'){ startNextRound(); initialLockHandled=true; } });
    controls.addEventListener('unlock',()=>{ crosshairEl.style.display='none'; document.getElementById('info').style.display='block'; weaponGroup.visible=false; muzzleFlash.visible=false; aiming=false; shooting=false; setADS(false); });

    // Helpers
    const playerCollider=new THREE.Box3(), tempBox=new THREE.Box3(), enemyCollider=new THREE.Box3(), muzzleWorldPosition=new THREE.Vector3();
    const raycaster=new THREE.Raycaster(), tmpVec=new THREE.Vector3(), tmpDir=new THREE.Vector3(), tmpQuat=new THREE.Quaternion(), tmpEuler=new THREE.Euler(0,0,0,'YXZ');
    const spawnCandidate=new THREE.Vector3();
    const spawnFallback=new THREE.Vector3();

    // Spread
    let spreadBaseHip=THREE.MathUtils.degToRad(.35), spreadBaseADS=THREE.MathUtils.degToRad(.14);
    let spreadMaxHip=THREE.MathUtils.degToRad(2.2), spreadMaxADS=THREE.MathUtils.degToRad(.6);
    let spreadCur=spreadBaseHip, spreadIncPerShot=THREE.MathUtils.degToRad(.25), spreadRecoverRate=THREE.MathUtils.degToRad(1.2);

    // FOV/ADS transition
    let isADS=false, adsT=0; // 0->hip, 1->ads
    function setADS(v){ isADS=v; }

    // Tracers & effects
    const tracers=[]; function spawnTracer(from,to,opacity=.8){ const g=new THREE.BufferGeometry().setFromPoints([from.clone(),to.clone()]); const m=new THREE.LineBasicMaterial({transparent:true,opacity}); const line=new THREE.Line(g,m); scene.add(line); tracers.push({line,life:.06}); }
    function showHitmarker(){ hitmarkerEl.classList.remove('hitmarker--show'); void hitmarkerEl.offsetWidth; hitmarkerEl.classList.add('hitmarker--show'); }
    function screenShake(intensity=.02,time=.08){ shake.time=time; shake.intensity=intensity; shake.duration=time; }
    const shake={ time:0, intensity:0, duration:0, offset:new THREE.Vector3() };
    function crosshairBloom(){ crosshairEl.style.transform='translate(-50%,-50%) scale(1.25)'; setTimeout(()=>{ crosshairEl.style.transform='translate(-50%,-50%) scale(1)'; },70); }

    // Noise/hearing
    let lastNoiseAt=-Infinity; const noise={ pos:new THREE.Vector3(), radius:28 };
    function noteGunshotNoise(){ noise.pos.copy(controls.getObject().position); lastNoiseAt=performance.now(); }

    function resetGame(){
      enemies.forEach(e=>scene.remove(e.mesh)); tracers.forEach(t=>scene.remove(t.line)); lootItems.forEach(l=>scene.remove(l.mesh));
      enemies.length=0; tracers.length=0; lootItems.length=0;
      player.velocity.set(0,0,0); player.health=100; player.ammo=30; player.reserve=120; player.fireCooldown=0; player.isReloading=false; player.alive=true; healthBarEl.style.width='100%'; updateAmmoDisplay();
      game.score=0; game.round=0; game.state='waiting'; game.enemiesRemaining=0; scoreEl.textContent='Skor: 0'; roundEl.textContent='Round: 0'; enemiesEl.textContent='Hayatta Kalan Düşman: 0'; gameOverEl.style.display='none'; overlayEl.style.background='rgba(255,0,0,0)';
      controls.getObject().position.set(0,player.height,12); controls.getObject().rotation.set(0,0,0); camera.rotation.set(0,0,0);
      initialLockHandled=false; spreadCur=spreadBaseHip; setADS(false); adsT=0; camera.fov = baseFOV; camera.updateProjectionMatrix();
    }

    function startNextRound(){
      const p = difficulty.params;
      game.round+=1; roundEl.textContent=`Round: ${game.round}`;
      const enemiesToSpawn = p.spawnBase + Math.floor(game.round * p.spawnScale);
      game.enemiesRemaining=enemiesToSpawn; enemiesEl.textContent=`Hayatta Kalan Düşman: ${game.enemiesRemaining}`;
      game.spawnQueue=enemiesToSpawn; game.spawnDelay=0; game.state='spawning'; game.roundStartAt=performance.now();
      showRoundBanner(`ROUND ${game.round} — ${difficulty.name}`);
    }
    function showRoundBanner(text){ roundBannerEl.textContent=text; roundBannerEl.style.display='block'; roundBannerEl.style.opacity='1'; setTimeout(()=>{ roundBannerEl.style.transition='opacity .6s ease'; roundBannerEl.style.opacity='0'; setTimeout(()=>{ roundBannerEl.style.display='none'; roundBannerEl.style.transition=''; },600); },1200); }

    // Enemies (same AI as D)
    function spawnEnemy(){
      const spawnRadius=world.size/2 - 6;
      const statics=[...world.walls,...world.obstacles];
      const playerPos=controls.getObject().position;
      const minPlayerDistSq=14*14;
      const minEnemyBase=3.4;
      const clearance=0.9;
      const enemySpacingSteps=[
        minEnemyBase,
        Math.max(2.6, minEnemyBase*0.85),
        Math.max(2.2, minEnemyBase*0.7)
      ].map(v=>v*v);

      const candidateIsValid=(pos, enemySpacingSq)=>{
        const dx=playerPos.x-pos.x;
        const dz=playerPos.z-pos.z;
        if(dx*dx+dz*dz<minPlayerDistSq) return false;
        for(const obj of statics){
          tempBox.setFromObject(obj);
          if(pos.x>tempBox.min.x-clearance && pos.x<tempBox.max.x+clearance && pos.z>tempBox.min.z-clearance && pos.z<tempBox.max.z+clearance){
            return false;
          }
        }
        if(enemySpacingSq>0){
          for(const other of enemies){
            const mesh=other.mesh; if(!mesh) continue;
            const ox=mesh.position.x-pos.x;
            const oz=mesh.position.z-pos.z;
            if(ox*ox+oz*oz<enemySpacingSq) return false;
          }
        }
        return true;
      };

      let found=false;
      for(const enemySpacingSq of enemySpacingSteps){
        for(let attempt=0; attempt<28 && !found; attempt++){
          const angle=Math.random()*Math.PI*2;
          const distance=THREE.MathUtils.randFloat(spawnRadius*.5,spawnRadius);
          spawnCandidate.set(Math.cos(angle)*distance,0,Math.sin(angle)*distance);
          if(candidateIsValid(spawnCandidate, enemySpacingSq)){
            found=true;
          }
        }
        if(found) break;
      }

      const relaxedSpacingSq=enemySpacingSteps[enemySpacingSteps.length-1];
      if(!found){
        const minOffset=Math.sqrt(minPlayerDistSq)+2;
        const radialStep=Math.max(2.5, Math.sqrt(relaxedSpacingSq)*0.9);
        for(let dirIdx=0; dirIdx<12 && !found; dirIdx++){
          const angleBase=(Math.PI*2*dirIdx)/12;
          const angle=angleBase+THREE.MathUtils.randFloatSpread(.25);
          const dirX=Math.cos(angle);
          const dirZ=Math.sin(angle);
          for(let dist=minOffset; dist<=spawnRadius && !found; dist+=radialStep){
            spawnFallback.set(
              THREE.MathUtils.clamp(playerPos.x+dirX*dist,-spawnRadius,spawnRadius),
              0,
              THREE.MathUtils.clamp(playerPos.z+dirZ*dist,-spawnRadius,spawnRadius)
            );
            if(candidateIsValid(spawnFallback, relaxedSpacingSq)){
              spawnCandidate.copy(spawnFallback);
              found=true;
            }
          }
        }
      }

      if(!found){
        const minOffset=Math.sqrt(minPlayerDistSq)+1;
        for(let attempt=0; attempt<32 && !found; attempt++){
          const angle=Math.random()*Math.PI*2;
          const dist=THREE.MathUtils.randFloat(minOffset, spawnRadius);
          spawnFallback.set(
            THREE.MathUtils.clamp(playerPos.x+Math.cos(angle)*dist,-spawnRadius,spawnRadius),
            0,
            THREE.MathUtils.clamp(playerPos.z+Math.sin(angle)*dist,-spawnRadius,spawnRadius)
          );
          if(candidateIsValid(spawnFallback, relaxedSpacingSq)){
            spawnCandidate.copy(spawnFallback);
            found=true;
          }
        }
      }

      if(!found){
        const angle=Math.random()*Math.PI*2;
        const dist=Math.max(spawnRadius-2, Math.sqrt(minPlayerDistSq));
        spawnCandidate.set(Math.cos(angle)*dist,0,Math.sin(angle)*dist);
        if(!candidateIsValid(spawnCandidate, relaxedSpacingSq)){
          const relaxedFallbackSq=Math.max(relaxedSpacingSq*0.64, 1.8*1.8);
          let placed=false;
          for(let attempt=0; attempt<24 && !placed; attempt++){
            const altAngle=Math.random()*Math.PI*2;
            const altDist=THREE.MathUtils.randFloat(Math.sqrt(minPlayerDistSq)+1, spawnRadius);
            spawnFallback.set(Math.cos(altAngle)*altDist,0,Math.sin(altAngle)*altDist);
            if(candidateIsValid(spawnFallback, relaxedFallbackSq)){
              spawnCandidate.copy(spawnFallback);
              placed=true;
            }
          }
          if(!placed){
            for(let attempt=0; attempt<24 && !placed; attempt++){
              const altAngle=Math.random()*Math.PI*2;
              const altDist=THREE.MathUtils.randFloat(Math.sqrt(minPlayerDistSq)+1, spawnRadius);
              spawnFallback.set(Math.cos(altAngle)*altDist,0,Math.sin(altAngle)*altDist);
              if(candidateIsValid(spawnFallback, 0)){
                spawnCandidate.copy(spawnFallback);
                placed=true;
              }
            }
          }
          if(!placed){
            spawnCandidate.set(
              THREE.MathUtils.clamp(-playerPos.x, -spawnRadius, spawnRadius),
              0,
              THREE.MathUtils.clamp(-playerPos.z, -spawnRadius, spawnRadius)
            );
          }
        }
      }
      const mat=enemyMaterialTemplate.clone();
      const clonedMap=mat.map;
      mat.map=enemyUniformTexture;
      if(clonedMap && clonedMap!==enemyUniformTexture && typeof clonedMap.dispose==='function'){
        clonedMap.dispose();
      }
      mat.color.setHSL(THREE.MathUtils.randFloat(.55,.62),.45,.55);
      const enemyMesh=new THREE.Mesh(enemyGeometry,mat); enemyMesh.position.set(spawnCandidate.x,1.5,spawnCandidate.z); enemyMesh.castShadow=enemyMesh.receiveShadow=true; scene.add(enemyMesh);
      const p = difficulty.params;
      const enemy={ mesh:enemyMesh, health:85+game.round*6, maxHealth:85+game.round*6, state:'patrol', subTimer:0, targetPoint:new THREE.Vector3(), chaseSpeed:movementConfig.enemyChase, patrolSpeed:movementConfig.enemyPatrol, lastSeenPlayerAt:new THREE.Vector3(), fireCooldown:THREE.MathUtils.randFloat(.8,1.4), burstShotsLeft:0, burstSize:THREE.MathUtils.randInt(p.burstSize[0], p.burstSize[1]), burstGap:.14, restAfterBurst:p.restAfterBurst, aimSpread:p.aimSpread, strafeTimer:0, strafeDir:(Math.random()<.5?-1:1), firstShotArm:THREE.MathUtils.randFloat(p.firstShotDelay[0], p.firstShotDelay[1]), suppressedUntil:0 };
      pickNewPatrolPoint(enemy); enemies.push(enemy);
      return true;
    }
    function pickNewPatrolPoint(enemy){ enemy.targetPoint.set(THREE.MathUtils.randFloatSpread(world.size*.6),0,THREE.MathUtils.randFloatSpread(world.size*.6)); enemy.subTimer=THREE.MathUtils.randFloat(3,7); }
    const raycaster2=new THREE.Raycaster();
    function hasLineOfSight(from,to){ const dir=tmpDir.subVectors(to,from).normalize(); raycaster2.set(from.clone().add(new THREE.Vector3(0,1.3,0)),dir); const statics=[...world.walls,...world.obstacles]; const hits=raycaster2.intersectObjects(statics,false); if(!hits.length) return true; const dist=from.distanceTo(to); return hits[0].distance > dist-0.5; }
    function nearestCoverPoint(enemy){ const epos=enemy.mesh.position, ppos=controls.getObject().position; let best=null, bestDist=Infinity; for(const ob of world.obstacles){ const b=new THREE.Box3().setFromObject(ob); const c=b.getCenter(new THREE.Vector3()); const d=epos.distanceTo(c); if(d<bestDist){ bestDist=d; best={box:b, center:c, mesh:ob}; } } if(!best) return null; const away=new THREE.Vector3().subVectors(best.center,ppos).setY(0).normalize(); const half=best.box.getSize(new THREE.Vector3()).multiplyScalar(.5); const offset=new THREE.Vector3(away.x*half.x,0,away.z*half.z); return best.center.clone().add(offset.multiplyScalar(1.1)); }

    function enemyHitscanShoot(enemy, delta){
      const p = difficulty.params;
      const now = performance.now();
      if(now - game.roundStartAt < 1200) return;
      const dt = Number.isFinite(delta) ? delta : 0.016;
      const origin=enemy.mesh.position.clone().add(new THREE.Vector3(0,1.3,0));
      let toPlayer=controls.getObject().position.clone().add(new THREE.Vector3(0,1,0)).sub(origin).normalize();
      const extraSpread = now < enemy.suppressedUntil ? THREE.MathUtils.degToRad(2.2) : 0;
      const yawOff=(Math.random()*2-1)*(enemy.aimSpread+extraSpread);
      const pitchOff=(Math.random()*2-1)*(enemy.aimSpread*0.6+extraSpread*0.4);
      tmpEuler.set(pitchOff,yawOff,0); tmpQuat.setFromEuler(tmpEuler); const dir=toPlayer.clone().applyQuaternion(tmpQuat).normalize();
      raycaster.set(origin,dir);
      const statics=[...world.walls,...world.obstacles];
      const intersects=raycaster.intersectObjects(statics,false);
      let hitPoint=origin.clone().add(dir.clone().multiplyScalar(200));
      const playerPos=controls.getObject().position.clone().add(new THREE.Vector3(0,1,0)); const distToPlayer=origin.distanceTo(playerPos);
      let blocked=false; for(const s of statics){ const arr=raycaster.intersectObject(s,false); if(arr.length && arr[0].distance<distToPlayer){ blocked=true; break; } }
      if(!blocked){ damagePlayer(p.enemyDamage); hitPoint=playerPos; } else if(intersects.length){ hitPoint=intersects[0].point; }
      spawnTracer(origin,hitPoint,.45);
    }

    function reloadWeapon(){ if(player.isReloading || player.ammo===player.maxAmmo || player.reserve<=0) return; player.isReloading=true; player.reloadTimer=player.reloadTime; }
    function updateAmmoDisplay(){ ammoEl.textContent=`${player.ammo} / ${player.reserve}`; }
    function damagePlayer(amount){ if(!player.alive) return; player.health=Math.max(0,player.health-amount); const r=player.health/100; healthBarEl.style.width=`${r*100}%`; overlayEl.style.background='rgba(255,0,0,.35)'; setTimeout(()=>overlayEl.style.background='rgba(255,0,0,0)',180); player.lastDamagedAt=performance.now(); if(player.health<=0) handleGameOver(); }
    function handleGameOver(){ player.alive=false; game.state='over'; gameOverEl.style.display='grid'; controls.unlock(); }

    function removeEnemy(enemy, giveScore=true){ const i=enemies.indexOf(enemy); if(i!==-1){ maybeDropLoot(enemy.mesh.position); scene.remove(enemy.mesh); enemies.splice(i,1); if(giveScore){ game.score+=10; scoreEl.textContent=`Skor: ${game.score}`; } game.enemiesRemaining-=1; enemiesEl.textContent=`Hayatta Kalan Düşman: ${Math.max(game.enemiesRemaining,0)}`; if(game.enemiesRemaining<=0 && game.spawnQueue<=0 && enemies.length===0){ setTimeout(startNextRound,2000); } } }

    // Player hitscan with zones
    function hitscanShoot(){ if(!player.alive || player.isReloading || player.ammo<=0) return;
      camera.getWorldDirection(tmpDir).normalize();
      const base = isADS ? spreadCur : spreadCur;
      const yawOff=(Math.random()*2-1)*base, pitchOff=(Math.random()*2-1)*base*.7; tmpEuler.set(pitchOff,yawOff,0); tmpQuat.setFromEuler(tmpEuler); tmpDir.applyQuaternion(tmpQuat).normalize();
      const origin=camera.getWorldPosition(new THREE.Vector3()); muzzleFlash.getWorldPosition(muzzleWorldPosition);
      raycaster.set(origin,tmpDir); const staticObjs=[...world.walls,...world.obstacles]; const enemyMeshes=enemies.map(e=>e.mesh);
      const intersects=raycaster.intersectObjects([...enemyMeshes,...staticObjs],false);
      let hitPoint=null;
      if(intersects.length){ const first=intersects[0]; hitPoint=first.point;
        if(enemyMeshes.includes(first.object)){ const e=enemies.find(en=>en.mesh===first.object); const yLocal=first.point.y - e.mesh.position.y; let dmg=30; if(yLocal>=1.0) dmg=110; else if(yLocal>=0.3) dmg=35; else dmg=22; e.health-=dmg; const orig=e.mesh.material.emissive.clone(); e.mesh.material.emissive.set(yLocal>=1.0?0xff7777:(yLocal>=0.3?0xff3333:0xff2211)); setTimeout(()=>{ e.mesh.material.emissive.copy(orig); },120); showHitmarker(); screenShake(yLocal>=1.0?0.02:0.012,.06); if(e.health<=0) removeEnemy(e); else { e.suppressedUntil = performance.now() + 700; } }
        else { spawnImpactDecal(first.point, first.face?.normal); }
      } else { hitPoint=origin.clone().add(tmpDir.clone().multiplyScalar(200)); }
      if(hitPoint) spawnTracer(muzzleWorldPosition,hitPoint);
      player.ammo-=1; updateAmmoDisplay(); player.fireCooldown=.1; muzzleFlash.visible=true; setTimeout(()=>muzzleFlash.visible=false,45);
      if(!isADS) crosshairBloom();
      // spread growth depends on ADS
      const inc = isADS ? THREE.MathUtils.degToRad(.12) : spreadIncPerShot;
      spreadCur = Math.min(spreadCur + inc, isADS ? spreadMaxADS : spreadMaxHip);
      noteGunshotNoise();
    }

    function spawnImpactDecal(point, normal=new THREE.Vector3(0,1,0)){ const s=new THREE.Sprite(new THREE.SpriteMaterial({ map:muzzleFlashTexture, color:0xddddff, blending:THREE.AdditiveBlending, transparent:true, opacity:.7 })); s.scale.set(.5,.5,.5); s.position.copy(point); if(normal){ const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), normal.clone().normalize()); s.quaternion.copy(q);} scene.add(s); setTimeout(()=>{ scene.remove(s); },80); }

    // Loot
    function maybeDropLoot(pos){ const roll=Math.random(); if(roll>0.6) return; const type=roll<0.18?'med':'ammo'; const amount=type==='med'?THREE.MathUtils.randInt(20,35):THREE.MathUtils.randInt(20,60); const mesh=buildLootMesh(type); mesh.position.copy(pos).add(new THREE.Vector3(0,.5,0)); mesh.rotation.y=Math.random()*Math.PI*2; scene.add(mesh); lootItems.push({mesh,type,amount,bob:Math.random()*Math.PI*2,baseY:mesh.position.y}); }
    function buildLootMesh(type){ const g=type==='med'? new THREE.TorusGeometry(.35,.12,12,24) : new THREE.BoxGeometry(.7,.4,.5); const m=new THREE.MeshStandardMaterial({ color:type==='med'?0x4ef58f:0xffd24d, emissive:type==='med'?0x0a3318:0x332508, metalness:.2, roughness:.35 }); const mesh=new THREE.Mesh(g,m); mesh.castShadow=mesh.receiveShadow=true; const icon=new THREE.Sprite(new THREE.SpriteMaterial({ map:null, color:type==='med'?0x9fffe0:0xfff1b3, transparent:true, opacity:.9 })); icon.scale.set(.45,.45,.45); icon.position.set(0,.5,0); mesh.add(icon); return mesh; }
    function tryPickupLoot(){ const p=controls.getObject().position; for(let i=lootItems.length-1;i>=0;i--){ const l=lootItems[i]; if(l.mesh.position.distanceTo(p)<1.7){ if(l.type==='ammo'){ const old=player.reserve; player.reserve=Math.min(player.reserveMax, player.reserve+l.amount); if(player.isReloading===false && player.ammo===0) reloadWeapon(); updateAmmoDisplay(); showPickup(`+${player.reserve-old} mermi`); } else { const old=player.health; player.health=Math.min(100, player.health+l.amount); const r=player.health/100; healthBarEl.style.width=`${r*100}%`; showPickup(`+${player.health-old} can`);} scene.remove(l.mesh); lootItems.splice(i,1);} } }
    function showPickup(text){ pickupBannerEl.textContent=text; pickupBannerEl.classList.add('show-pickup'); setTimeout(()=>pickupBannerEl.classList.remove('show-pickup'),600); }

    // Out of combat regen
    function updateRegen(delta){ const now=performance.now(); if(now - player.lastDamagedAt > 4000 && player.health>0 && player.health<60){ player.health = Math.min(60, player.health + 6*delta); const r=player.health/100; healthBarEl.style.width=`${r*100}%`; } }

    // Weapon sway & bob
    let prevYaw=0, prevPitch=0, bobTime=0;
    function updateWeaponPose(delta){
      const yaw = controls.getObject().rotation.y;
      const pitch = camera.rotation.x;
      const dy = THREE.MathUtils.euclideanModulo(yaw - prevYaw + Math.PI, 2*Math.PI) - Math.PI;
      const dp = pitch - prevPitch;
      prevYaw = yaw; prevPitch = pitch;

      // Mouse look sway
      const swayFactor = isADS ? 0.35 : 0.6;
      const maxSwayPos = isADS ? 0.025 : 0.045;
      const maxSwayRot = isADS ? 0.015 : 0.03;

      weaponGroup.position.x = 0.32 - THREE.MathUtils.clamp(dy, -0.06, 0.06) * swayFactor;
      weaponGroup.position.y = -0.30 + THREE.MathUtils.clamp(dp, -0.06, 0.06) * swayFactor;
      weaponGroup.rotation.z = THREE.MathUtils.clamp(-dy * swayFactor, -maxSwayRot, maxSwayRot);
      weaponGroup.rotation.x = -0.05 + THREE.MathUtils.clamp(-dp * swayFactor, -maxSwayRot, maxSwayRot);

      // Movement bob
      const moving = (keyState['KeyW']||keyState['KeyA']||keyState['KeyS']||keyState['KeyD']);
      if(moving && player.onGround){
        bobTime += delta * (isADS?8:10);
        const bobX = Math.sin(bobTime) * (isADS?0.01:0.02);
        const bobY = Math.abs(Math.cos(bobTime*0.5)) * (isADS?0.01:0.02);
        weaponGroup.position.x += bobX;
        weaponGroup.position.y -= bobY;
      }
    }

    function updatePlayer(delta){
      if(!controls.isLocked) return;
      const sprinting=keyState['ShiftLeft']||keyState['ShiftRight'];
      // ADS only if the input is held and player is free to aim
      const wantsADS = aiming && player.alive && !player.isReloading;
      const effectiveADS = wantsADS && !sprinting;
      setADS(effectiveADS);

      // ADS transition
      const target = isADS ? 1 : 0;
      adsT = THREE.MathUtils.damp(adsT, target, 12, delta); // smooth
      const fovTarget = sprinting ? sprintFOV : THREE.MathUtils.lerp(baseFOV, adsFOV, adsT);
      camera.fov = THREE.MathUtils.damp(camera.fov, fovTarget, 10, delta);
      camera.updateProjectionMatrix();
      // spread base/limitleri
      const base = isADS ? spreadBaseADS : spreadBaseHip;
      const max  = isADS ? spreadMaxADS  : spreadMaxHip;
      spreadCur = THREE.MathUtils.clamp(spreadCur, base, max);
      crosshairEl.style.opacity = isADS ? 0.25 : 0.95;
      crosshairEl.style.transform = isADS ? 'translate(-50%, -50%) scale(0.8)' : 'translate(-50%, -50%) scale(1)';

      const moveSpeed = player.speed * (sprinting ? player.sprintMultiplier : 1);
      let f=0,r=0; if(keyState['KeyW']) f+=1; if(keyState['KeyS']) f-=1; if(keyState['KeyD']) r+=1; if(keyState['KeyA']) r-=1;
      const len=Math.hypot(f,r); if(len>0){ f/=len; r/=len; }
      const oldPos=controls.getObject().position.clone(); const dist=moveSpeed*delta;
      if(f!==0) controls.moveForward(f*dist); if(r!==0) controls.moveRight(r*dist);
      if(player.onGround && keyState['Space']){ player.velocity.y=player.jumpStrength; player.onGround=false; }
      player.velocity.y -= player.gravity*delta; controls.getObject().position.y += player.velocity.y*delta;
      if(controls.getObject().position.y<player.height){ player.velocity.y=0; controls.getObject().position.y=player.height; player.onGround=true; } else if(player.velocity.y<0){ player.onGround=false; }
      playerCollider.setFromCenterAndSize(controls.getObject().position,new THREE.Vector3(1,player.height,1));
      const colliders=[...world.walls,...world.obstacles]; for(const c of colliders){ tempBox.setFromObject(c); if(playerCollider.intersectsBox(tempBox)){ controls.getObject().position.copy(oldPos); player.velocity.y=0; player.onGround=true; break; } }
      if(player.isReloading){ player.reloadTimer-=delta; if(player.reloadTimer<=0){ const need=player.maxAmmo-player.ammo; const toLoad=Math.min(need,player.reserve); player.ammo+=toLoad; player.reserve-=toLoad; updateAmmoDisplay(); player.isReloading=false; } }
      // recovery
      const recRate = isADS ? THREE.MathUtils.degToRad(1.7) : spreadRecoverRate;
      spreadCur = Math.max(base, spreadCur - recRate*delta);
      if(shake.offset.lengthSq()>0){
        camera.position.sub(shake.offset);
        shake.offset.set(0,0,0);
      }
      if(shake.time>0){
        shake.time=Math.max(0, shake.time-delta);
        const falloff = shake.duration>0 ? shake.time/shake.duration : 0;
        const intensity = shake.intensity * (0.6 + 0.4 * falloff);
        shake.offset.set(
          (Math.random()*2-1)*intensity,
          (Math.random()*2-1)*intensity*0.6,
          (Math.random()*2-1)*intensity*0.4
        );
        camera.position.add(shake.offset);
      }
      updateRegen(delta);
      updateWeaponPose(delta);
    }

    function updateTracers(delta){ for(let i=tracers.length-1;i>=0;i--){ const t=tracers[i]; t.life-=delta; if(t.life<=0){ scene.remove(t.line); tracers.splice(i,1);} else t.line.material.opacity=Math.max(0, t.life/.06); } }

    function updateLoot(delta){ const t=performance.now()/1000; for(const l of lootItems){ l.mesh.rotation.y += delta*1.6; const anchor = Number.isFinite(l.baseY) ? l.baseY : l.mesh.position.y; l.mesh.position.y = Math.max(.3, anchor + Math.sin(t + l.bob)*.12); } tryPickupLoot(); }

    // Enemy update copied from D
    function updateEnemies(delta){
      const playerPos=controls.getObject().position.clone(); const statics=[...world.walls,...world.obstacles]; const p=difficulty.params;
      for(const enemy of enemies){
        const epos=enemy.mesh.position; const flatToPlayer=tmpVec.subVectors(playerPos,epos).setY(0); const distance=flatToPlayer.length();
        const heard = performance.now()-lastNoiseAt < 1500 && epos.distanceTo(noise.pos) < noise.radius;
        const sees = distance < p.losRange && hasLineOfSight(epos, playerPos);
        if(sees){ enemy.lastSeenPlayerAt.copy(playerPos); }
        if(sees && distance < p.engage){ enemy.state='attack'; }
        else if(sees || heard){ enemy.state='chase'; }
        else if(enemy.state!=='patrol' && enemy.subTimer<=0){ enemy.state='patrol'; pickNewPatrolPoint(enemy); }

        if(enemy.state==='patrol'){ enemy.subTimer-=delta; moveTowards(enemy, enemy.targetPoint, enemy.patrolSpeed, delta); if(enemy.subTimer<=0) pickNewPatrolPoint(enemy); }
        if(enemy.state==='chase'){ const tgt=enemy.lastSeenPlayerAt.clone(); if(!sees && Math.random()<.02){ const cover=nearestCoverPoint(enemy); if(cover) tgt.copy(cover);} moveTowards(enemy, tgt, enemy.chaseSpeed, delta); }
        if(enemy.state==='attack'){
          const lookDir=flatToPlayer.clone().normalize(); enemy.mesh.lookAt(enemy.mesh.position.clone().add(lookDir));
          if(distance < p.retreat){ enemy.mesh.position.addScaledVector(lookDir, -enemy.chaseSpeed*delta*1.05); }
          else if(distance > p.engage){ enemy.mesh.position.addScaledVector(lookDir, enemy.chaseSpeed*delta); }
          else { enemy.strafeTimer-=delta; if(enemy.strafeTimer<=0){ enemy.strafeTimer=THREE.MathUtils.randFloat(.3,.8); enemy.strafeDir=(Math.random()<.5?-1:1);} const strafe=new THREE.Vector3(-lookDir.z,0,lookDir.x).multiplyScalar(enemy.chaseSpeed*.7*enemy.strafeDir*delta); enemy.mesh.position.add(strafe); }
          if(enemy.firstShotArm>0){
            enemy.firstShotArm=Math.max(0, enemy.firstShotArm-delta);
          }
          enemy.fireCooldown -= delta;
          if(enemy.fireCooldown<=0){
            if(enemy.firstShotArm>0){
              enemy.fireCooldown = enemy.firstShotArm;
            } else {
              if(enemy.burstShotsLeft<=0){ enemy.burstShotsLeft=THREE.MathUtils.randInt(p.burstSize[0], p.burstSize[1]); enemy.fireCooldown=0; }
              if(enemy.burstShotsLeft>0){ enemyHitscanShoot(enemy, delta); enemy.burstShotsLeft-=1; enemy.fireCooldown = enemy.burstShotsLeft>0 ? 0.14 : p.restAfterBurst + THREE.MathUtils.randFloat(-0.2,0.2); }
            }
          }
        }

        tempBox.setFromObject(enemy.mesh);
        for(const c of statics){ const box=new THREE.Box3().setFromObject(c); if(tempBox.intersectsBox(box)){ const ep=enemy.mesh.position; const closest=box.clampPoint(ep,new THREE.Vector3()); const push=new THREE.Vector3().subVectors(ep,closest); if(push.lengthSq()===0){ push.subVectors(ep, box.getCenter(new THREE.Vector3())); } if(push.lengthSq()===0){ push.set(Math.random()-.5,0,Math.random()-.5);} push.y=0; push.normalize(); enemy.mesh.position.addScaledVector(push,.3); tempBox.setFromObject(enemy.mesh); } }
      }
    }

    function moveTowards(enemy,target,speed,delta){ const dir=tmpVec.subVectors(target,enemy.mesh.position); dir.y=0; const d=dir.length(); if(d>.5){ dir.normalize(); enemy.mesh.position.addScaledVector(dir, speed*delta); enemy.mesh.lookAt(enemy.mesh.position.clone().add(dir)); } }

    function updateMinimap(){ const ctx=minimapCtx, size=minimapCanvas.width, scale=size/world.size; ctx.clearRect(0,0,size,size); ctx.fillStyle='rgba(10,18,28,.9)'; ctx.fillRect(0,0,size,size); ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.strokeRect(2,2,size-4,size-4); const playerPos=controls.getObject().position; const yaw=controls.getObject().rotation.y; function project(pos){ return {x:size/2+pos.x*scale, y:size/2+pos.z*scale}; } ctx.fillStyle='#50c8ff'; const p=project(playerPos); ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(p.x,p.y); const r=18; ctx.lineTo(p.x+Math.sin(yaw-.35)*r, p.y+Math.cos(yaw-.35)*r); ctx.lineTo(p.x+Math.sin(yaw+.35)*r, p.y+Math.cos(yaw+.35)*r); ctx.closePath(); ctx.fillStyle='rgba(80,200,255,.25)'; ctx.fill(); ctx.fillStyle='#ff5c3b'; enemies.forEach(e=>{ const ep=project(e.mesh.position); ctx.beginPath(); ctx.arc(ep.x,ep.y,5,0,Math.PI*2); ctx.fill(); }); }

    function animate(){ requestAnimationFrame(animate); const delta=Math.min(.05, clock.getDelta()); if(player.fireCooldown>0) player.fireCooldown-=delta; if(shooting && player.fireCooldown<=0) hitscanShoot(); if(game.state!=='over'){ updatePlayer(delta); updateEnemies(delta); updateTracers(delta); updateLoot(delta); updateMinimap(); if(game.state==='spawning'){ game.spawnDelay-=delta; if(game.spawnDelay<=0 && game.spawnQueue>0){ const spawned=spawnEnemy(); if(spawned){ game.spawnQueue-=1; game.spawnDelay=THREE.MathUtils.randFloat(.6,1.2);} else { game.spawnDelay=Math.max(game.spawnDelay,0.45); } } else if(game.spawnQueue<=0){ game.state='inRound'; } } } renderer.render(scene,camera); }

    window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    const patchContext = {
      THREE,
      scene,
      camera,
      renderer,
      controls,
      clock,
      world,
      movementConfig,
      player,
      game,
      enemies,
      lootItems,
      difficulty,
      keyState,
      spawnTracer,
      spawnImpactDecal,
      showHitmarker,
      screenShake,
      crosshairBloom,
      noteGunshotNoise,
      muzzleFlash,
      muzzleWorldPosition,
      enemyMaterialTemplate,
      getNoiseInfo: () => ({ lastNoiseAt, noise }),
      refs: {
        tempBox,
        raycaster,
        playerCollider,
        getShooting: () => shooting,
        setShooting: v => { shooting = v; },
        getAiming: () => aiming,
        setAiming: v => { aiming = v; },
        getADS: () => isADS,
        setADS: v => setADS(v),
        getAdsT: () => adsT,
        setAdsT: v => { adsT = v; },
      },
      functions: {
        get updatePlayer(){ return updatePlayer; },
        set updatePlayer(fn){ updatePlayer = fn; },
        get hitscanShoot(){ return hitscanShoot; },
        set hitscanShoot(fn){ hitscanShoot = fn; },
        get enemyHitscanShoot(){ return enemyHitscanShoot; },
        set enemyHitscanShoot(fn){ enemyHitscanShoot = fn; },
        get spawnEnemy(){ return spawnEnemy; },
        set spawnEnemy(fn){ spawnEnemy = fn; },
        get updateEnemies(){ return updateEnemies; },
        set updateEnemies(fn){ updateEnemies = fn; },
        get moveTowards(){ return moveTowards; },
        set moveTowards(fn){ moveTowards = fn; },
        get updateMinimap(){ return updateMinimap; },
        set updateMinimap(fn){ updateMinimap = fn; },
        get startNextRound(){ return startNextRound; },
        set startNextRound(fn){ startNextRound = fn; },
        get removeEnemy(){ return removeEnemy; },
        set removeEnemy(fn){ removeEnemy = fn; },
        get damagePlayer(){ return damagePlayer; },
        set damagePlayer(fn){ damagePlayer = fn; },
        get showRoundBanner(){ return showRoundBanner; },
        set showRoundBanner(fn){ showRoundBanner = fn; },
        get animate(){ return animate; },
        set animate(fn){ animate = fn; },
        get updateWeaponPose(){ return updateWeaponPose; },
        set updateWeaponPose(fn){ updateWeaponPose = fn; },
        get updateRegen(){ return updateRegen; },
        set updateRegen(fn){ updateRegen = fn; },
        get updateLoot(){ return updateLoot; },
        set updateLoot(fn){ updateLoot = fn; },
        get updateTracers(){ return updateTracers; },
        set updateTracers(fn){ updateTracers = fn; },
        get updateAmmoDisplay(){ return updateAmmoDisplay; },
        set updateAmmoDisplay(fn){ updateAmmoDisplay = fn; },
        get maybeDropLoot(){ return maybeDropLoot; },
        set maybeDropLoot(fn){ maybeDropLoot = fn; },
      },
      ui: {
        hud: document.getElementById('hud'),
        roundEl,
        enemiesEl,
        scoreEl,
        ammoEl,
        healthBarEl,
        minimapCtx,
        pickupBannerEl,
      },
    };
    applyPatch(patchContext);
    resetGame(); animate();
  </script>
</body>
</html>
