<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="utf-8" />
    <title>Mini CS: Arena</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            color-scheme: dark;
        }

        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(circle at center, #121821, #050608 70%);
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            color: #fff;
        }

        #info {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 15px;
            text-align: center;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.7);
            line-height: 1.4;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 26px;
            height: 26px;
            transform: translate(-50%, -50%);
            display: grid;
            place-items: center;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
            opacity: 0.85;
            transition: transform 0.1s ease;
        }

        #crosshair::before {
            width: 2px;
            height: 100%;
        }

        #crosshair::after {
            width: 100%;
            height: 2px;
        }

        #scoreboard {
            position: absolute;
            top: 16px;
            left: 16px;
            font-size: 20px;
            display: grid;
            gap: 4px;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.7);
        }

        #ammo {
            position: absolute;
            bottom: 24px;
            right: 28px;
            font-size: 32px;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }

        #health {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: min(460px, 60vw);
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 999px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.1);
        }

        #health > span {
            display: block;
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #44ff9a, #31bfff);
            transition: width 0.2s ease;
        }

        #roundBanner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(42px, 5vw, 72px);
            font-weight: 700;
            text-align: center;
            letter-spacing: 6px;
            text-shadow: 0 0 14px rgba(0, 0, 0, 0.8);
            display: none;
        }

        #overlay {
            position: absolute;
            inset: 0;
            background: rgba(255, 0, 0, 0);
            transition: background 0.2s ease;
            pointer-events: none;
        }

        #minimap {
            position: absolute;
            right: 24px;
            top: 24px;
            width: 160px;
            height: 160px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.35);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
        }

        #gameOver {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            font-size: clamp(40px, 8vw, 90px);
            font-weight: 800;
            letter-spacing: 8px;
            text-align: center;
            backdrop-filter: blur(4px);
            background: rgba(0, 0, 0, 0.75);
            display: none;
        }

        #gameOver small {
            display: block;
            font-size: clamp(16px, 3vw, 22px);
            margin-top: 16px;
            font-weight: 400;
            letter-spacing: normal;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="hud">
        <div id="info">Oynamak için ekrana tıkla.<br />WASD: Hareket • Fare: Bakış &amp; Ateş • Space: Zıpla • Shift: Koş • R: Şarjör • Esc: Çık</div>
        <div id="crosshair"></div>
        <div id="scoreboard">
            <div id="score">Skor: 0</div>
            <div id="round">Round: 0</div>
            <div id="enemies">Hayatta Kalan Düşman: 0</div>
        </div>
        <div id="ammo">30 / 90</div>
        <div id="health"><span></span></div>
        <div id="roundBanner"></div>
        <div id="overlay"></div>
        <div id="minimap"><canvas width="200" height="200"></canvas></div>
        <div id="gameOver">OYUN BİTTİ<small>Yeniden başlamak için R tuşuna bas.</small></div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const scene = new THREE.Scene();

        const cubeLoader = new THREE.CubeTextureLoader();
        const skyTexture = cubeLoader
            .setPath('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/skyboxsun25/')
            .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);
        scene.background = skyTexture;
        scene.fog = new THREE.Fog(0x0b101a, 40, 180);

        const textureLoader = new THREE.TextureLoader();

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, renderer.domElement);
        scene.add(controls.getObject());

        const clock = new THREE.Clock();

        const world = {
            size: 120,
            walls: [],
            obstacles: []
        };

        const movementConfig = {
            playerWalk: 7.5,
            playerSprintMultiplier: 1.5,
            jumpStrength: 9,
            gravity: 28,
            enemyChase: 6.2,
            enemyPatrol: 3.5
        };

        const player = {
            velocity: new THREE.Vector3(),
            speed: movementConfig.playerWalk,
            sprintMultiplier: movementConfig.playerSprintMultiplier,
            jumpStrength: movementConfig.jumpStrength,
            gravity: movementConfig.gravity,
            onGround: false,
            height: 1.6,
            health: 100,
            ammo: 30,
            reserve: 90,
            maxAmmo: 30,
            fireCooldown: 0,
            reloadTime: 1.6,
            isReloading: false,
            alive: true
        };

        const game = {
            score: 0,
            round: 0,
            state: 'waiting',
            roundTimer: 0,
            enemiesRemaining: 0,
            spawnDelay: 0,
            spawnQueue: 0
        };

        const bullets = [];
        const enemyBullets = [];
        const enemies = [];
        const bulletSpeed = 240;
        const enemyBulletSpeed = 120;

        // Lighting
        const ambient = new THREE.AmbientLight(0x5a6370, 0.7);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xd0e4ff, 0.9);
        dirLight.position.set(35, 60, 25);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 220;
        scene.add(dirLight);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(world.size, world.size, 20, 20);
        floorGeo.rotateX(-Math.PI / 2);

        const floorColorMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg');
        floorColorMap.wrapS = THREE.RepeatWrapping;
        floorColorMap.wrapT = THREE.RepeatWrapping;
        floorColorMap.repeat.set(world.size / 6, world.size / 6);
        floorColorMap.colorSpace = THREE.SRGBColorSpace;

        const floorNormalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Normal.jpg');
        floorNormalMap.wrapS = THREE.RepeatWrapping;
        floorNormalMap.wrapT = THREE.RepeatWrapping;
        floorNormalMap.repeat.copy(floorColorMap.repeat);

        const floorRoughnessMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Roughness.jpg');
        floorRoughnessMap.wrapS = THREE.RepeatWrapping;
        floorRoughnessMap.wrapT = THREE.RepeatWrapping;
        floorRoughnessMap.repeat.copy(floorColorMap.repeat);

        const floorMat = new THREE.MeshStandardMaterial({
            map: floorColorMap,
            normalMap: floorNormalMap,
            roughnessMap: floorRoughnessMap,
            metalness: 0.15,
            roughness: 0.9
        });

        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.receiveShadow = true;
        scene.add(floor);

        const grid = new THREE.GridHelper(world.size, 24, 0x334050, 0x1a2530);
        scene.add(grid);

        // Walls
        const wallColorMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg');
        wallColorMap.wrapS = THREE.RepeatWrapping;
        wallColorMap.wrapT = THREE.RepeatWrapping;
        wallColorMap.colorSpace = THREE.SRGBColorSpace;

        const wallNormalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_normal.jpg');
        wallNormalMap.wrapS = THREE.RepeatWrapping;
        wallNormalMap.wrapT = THREE.RepeatWrapping;

        const wallRoughnessMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_roughness.jpg');
        wallRoughnessMap.wrapS = THREE.RepeatWrapping;
        wallRoughnessMap.wrapT = THREE.RepeatWrapping;

        const baseWallMaterial = new THREE.MeshStandardMaterial({
            map: wallColorMap,
            normalMap: wallNormalMap,
            roughnessMap: wallRoughnessMap,
            metalness: 0.25,
            roughness: 0.85
        });
        const wallHeight = 6;
        const wallThickness = 2;
        const arenaSize = world.size / 2;

        function createWall(x, z, width, depth) {
            const geometry = new THREE.BoxGeometry(width, wallHeight, depth);
            const material = baseWallMaterial.clone();
            material.map = baseWallMaterial.map.clone();
            material.normalMap = baseWallMaterial.normalMap.clone();
            material.roughnessMap = baseWallMaterial.roughnessMap.clone();

            const repeatX = Math.max(1, width / 6);
            const repeatY = Math.max(1, wallHeight / 2);
            material.map.repeat.set(repeatX, repeatY);
            material.normalMap.repeat.copy(material.map.repeat);
            material.roughnessMap.repeat.copy(material.map.repeat);

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, wallHeight / 2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            world.walls.push(mesh);
        }

        createWall(0, -arenaSize + wallThickness / 2, world.size, wallThickness);
        createWall(0, arenaSize - wallThickness / 2, world.size, wallThickness);
        createWall(-arenaSize + wallThickness / 2, 0, wallThickness, world.size);
        createWall(arenaSize - wallThickness / 2, 0, wallThickness, world.size);

        // Obstacles / covers
        const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x253246, metalness: 0.15, roughness: 0.7 });
        const obstaclePositions = [
            { x: -18, z: -10 },
            { x: 12, z: -15 },
            { x: -8, z: 16 },
            { x: 18, z: 12 },
            { x: 0, z: 0 },
            { x: -20, z: 22 },
            { x: 20, z: -22 }
        ];

        obstaclePositions.forEach(({ x, z }) => {
            const height = THREE.MathUtils.randFloat(2.2, 4.4);
            const width = THREE.MathUtils.randFloat(4, 10);
            const depth = THREE.MathUtils.randFloat(3, 8);
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const mesh = new THREE.Mesh(geometry, obstacleMaterial.clone());
            mesh.material.color.offsetHSL(Math.random() * 0.05, 0, 0);
            mesh.position.set(x, height / 2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            world.obstacles.push(mesh);
        });

        function createEnemyUniformTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#18273d');
            gradient.addColorStop(0.4, '#1f3553');
            gradient.addColorStop(1, '#101c2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(90, 180, 255, 0.3)';
            ctx.fillRect(0, canvas.height * 0.15, canvas.width, 18);
            ctx.fillRect(0, canvas.height * 0.45, canvas.width, 10);

            ctx.fillStyle = 'rgba(12, 18, 28, 0.7)';
            for (let i = 0; i < 6; i += 1) {
                ctx.fillRect(18, 24 + i * 38, canvas.width - 36, 6);
            }

            ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.fillRect(0, canvas.height * 0.05, canvas.width, 10);
            ctx.fillRect(0, canvas.height * 0.75, canvas.width, 6);

            return new THREE.CanvasTexture(canvas);
        }

        const enemyUniformTexture = createEnemyUniformTexture();
        enemyUniformTexture.wrapS = THREE.RepeatWrapping;
        enemyUniformTexture.wrapT = THREE.RepeatWrapping;
        enemyUniformTexture.colorSpace = THREE.SRGBColorSpace;
        enemyUniformTexture.needsUpdate = true;

        const enemyMaterialTemplate = new THREE.MeshStandardMaterial({
            map: enemyUniformTexture,
            metalness: 0.2,
            roughness: 0.65,
            emissive: new THREE.Color(0x050b14),
            emissiveIntensity: 0.25
        });

        // Decorative lights
        const pointLight = new THREE.PointLight(0x5ab9ff, 1.3, 65, 2);
        pointLight.position.set(0, 4.5, 0);
        pointLight.castShadow = false;
        scene.add(pointLight);

        const muzzleFlashTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/sprites/lensflare0_alpha.png');
        muzzleFlashTexture.colorSpace = THREE.SRGBColorSpace;

        const muzzleFlash = new THREE.Sprite(new THREE.SpriteMaterial({ map: muzzleFlashTexture, color: 0xfff6a8, transparent: true, blending: THREE.AdditiveBlending }));
        muzzleFlash.scale.set(1.6, 1.6, 1.6);
        muzzleFlash.center.set(0.5, 0);
        muzzleFlash.visible = false;
        muzzleFlash.position.set(0, 0, -0.1);

        const weaponGroup = new THREE.Group();

        const weaponBodyTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal/Metal_Plate_037_basecolor.jpg');
        weaponBodyTexture.wrapS = THREE.RepeatWrapping;
        weaponBodyTexture.wrapT = THREE.RepeatWrapping;
        weaponBodyTexture.repeat.set(2, 1);
        weaponBodyTexture.colorSpace = THREE.SRGBColorSpace;

        const weaponNormalTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal/Metal_Plate_037_normal.jpg');
        weaponNormalTexture.wrapS = THREE.RepeatWrapping;
        weaponNormalTexture.wrapT = THREE.RepeatWrapping;
        weaponNormalTexture.repeat.copy(weaponBodyTexture.repeat);

        const weaponRoughnessTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal/Metal_Plate_037_roughness.jpg');
        weaponRoughnessTexture.wrapS = THREE.RepeatWrapping;
        weaponRoughnessTexture.wrapT = THREE.RepeatWrapping;
        weaponRoughnessTexture.repeat.copy(weaponBodyTexture.repeat);

        const weaponMaterial = new THREE.MeshStandardMaterial({
            map: weaponBodyTexture,
            normalMap: weaponNormalTexture,
            roughnessMap: weaponRoughnessTexture,
            metalness: 0.7,
            roughness: 0.35
        });

        const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.12, 0.58), weaponMaterial);
        receiver.position.set(0, -0.02, -0.28);
        receiver.castShadow = false;
        weaponGroup.add(receiver);

        const gripMaterial = weaponMaterial.clone();
        gripMaterial.color.set(0x1d2129);
        const grip = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.26, 0.16), gripMaterial);
        grip.position.set(-0.03, -0.19, -0.06);
        grip.rotation.x = THREE.MathUtils.degToRad(12);
        weaponGroup.add(grip);

        const stock = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.32), weaponMaterial);
        stock.position.set(0, 0.01, 0.16);
        weaponGroup.add(stock);

        const barrelMaterial = weaponMaterial.clone();
        barrelMaterial.color.set(0x3a3f4b);
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.52, 16), barrelMaterial);
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0.02, 0.02, -0.54);
        weaponGroup.add(barrel);

        const handguardMaterial = weaponMaterial.clone();
        handguardMaterial.color.set(0x2c313c);
        const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.08, 0.3), handguardMaterial);
        handguard.position.set(0, -0.04, -0.48);
        weaponGroup.add(handguard);

        const sightMaterial = new THREE.MeshStandardMaterial({ color: 0x111519, metalness: 0.4, roughness: 0.2 });
        const rearSight = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.08), sightMaterial);
        rearSight.position.set(0, 0.05, -0.1);
        weaponGroup.add(rearSight);

        const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.05, 0.06), sightMaterial);
        frontSight.position.set(0.02, 0.04, -0.62);
        weaponGroup.add(frontSight);

        const muzzleAnchor = new THREE.Object3D();
        muzzleAnchor.position.set(0.25, -0.05, -0.9);
        weaponGroup.add(muzzleAnchor);
        muzzleAnchor.add(muzzleFlash);

        camera.add(weaponGroup);
        weaponGroup.position.set(0.32, -0.3, -0.55);
        weaponGroup.rotation.set(-0.05, 0.25, 0);
        weaponGroup.visible = false;

        const minimapCanvas = document.querySelector('#minimap canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // UI elements
        const scoreEl = document.getElementById('score');
        const roundEl = document.getElementById('round');
        const enemiesEl = document.getElementById('enemies');
        const ammoEl = document.getElementById('ammo');
        const healthBarEl = document.querySelector('#health > span');
        const roundBannerEl = document.getElementById('roundBanner');
        const overlayEl = document.getElementById('overlay');
        const gameOverEl = document.getElementById('gameOver');
        const crosshairEl = document.getElementById('crosshair');

        const keyState = {};
        document.addEventListener('keydown', (event) => {
            keyState[event.code] = true;

            if (event.code === 'KeyR') {
                if (!player.alive) {
                    resetGame();
                } else if (!player.isReloading && player.ammo < player.maxAmmo && player.reserve > 0) {
                    reloadWeapon();
                }
            }
        });

        document.addEventListener('keyup', (event) => {
            keyState[event.code] = false;
        });

        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) {
                shooting = true;
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                shooting = false;
            }
        });

        renderer.domElement.addEventListener('click', () => {
            if (!player.alive) return;
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            crosshairEl.style.display = 'block';
            document.getElementById('info').style.display = 'none';
            weaponGroup.visible = true;
        });

        controls.addEventListener('unlock', () => {
            crosshairEl.style.display = 'none';
            document.getElementById('info').style.display = 'block';
            weaponGroup.visible = false;
            muzzleFlash.visible = false;
        });

        let shooting = false;

        const playerCollider = new THREE.Box3();
        const tempBox = new THREE.Box3();
        const enemyCollider = new THREE.Box3();
        const muzzleWorldPosition = new THREE.Vector3();

        function resetGame() {
            enemies.forEach((enemy) => scene.remove(enemy.mesh));
            bullets.forEach((bullet) => scene.remove(bullet.mesh));
            enemyBullets.forEach((bullet) => scene.remove(bullet.mesh));
            enemies.length = 0;
            bullets.length = 0;
            enemyBullets.length = 0;

            player.velocity.set(0, 0, 0);
            player.health = 100;
            player.ammo = 30;
            player.reserve = 90;
            player.fireCooldown = 0;
            player.isReloading = false;
            player.alive = true;
            healthBarEl.style.width = '100%';
            updateAmmoDisplay();

            game.score = 0;
            game.round = 0;
            game.state = 'waiting';
            game.enemiesRemaining = 0;
            scoreEl.textContent = 'Skor: 0';
            roundEl.textContent = 'Round: 0';
            enemiesEl.textContent = 'Hayatta Kalan Düşman: 0';
            gameOverEl.style.display = 'none';
            overlayEl.style.background = 'rgba(255,0,0,0)';

            controls.getObject().position.set(0, player.height, 12);
            controls.getObject().rotation.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);

            startNextRound();
        }

        function startNextRound() {
            game.round += 1;
            roundEl.textContent = `Round: ${game.round}`;
            const enemiesToSpawn = 4 + Math.floor(game.round * 1.5);
            game.enemiesRemaining = enemiesToSpawn;
            enemiesEl.textContent = `Hayatta Kalan Düşman: ${game.enemiesRemaining}`;
            game.spawnQueue = enemiesToSpawn;
            game.spawnDelay = 0;
            game.state = 'spawning';
            showRoundBanner(`ROUND ${game.round}`);
        }

        function showRoundBanner(text) {
            roundBannerEl.textContent = text;
            roundBannerEl.style.display = 'block';
            roundBannerEl.style.opacity = '1';
            setTimeout(() => {
                roundBannerEl.style.transition = 'opacity 0.6s ease';
                roundBannerEl.style.opacity = '0';
                setTimeout(() => {
                    roundBannerEl.style.display = 'none';
                    roundBannerEl.style.transition = '';
                }, 600);
            }, 1200);
        }

        function spawnEnemy() {
            const spawnRadius = arenaSize - 6;
            const angle = Math.random() * Math.PI * 2;
            const distance = THREE.MathUtils.randFloat(spawnRadius * 0.5, spawnRadius);
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            const bodyGeometry = new THREE.CapsuleGeometry(0.6, 1.2, 6, 12);
            const bodyMaterial = enemyMaterialTemplate.clone();
            bodyMaterial.map = enemyMaterialTemplate.map.clone();
            bodyMaterial.map.repeat.copy(enemyMaterialTemplate.map.repeat);
            bodyMaterial.map.needsUpdate = true;
            bodyMaterial.color.setHSL(THREE.MathUtils.randFloat(0.55, 0.62), 0.45, 0.55);
            const enemyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            enemyMesh.position.set(x, 1.5, z);
            enemyMesh.castShadow = true;
            enemyMesh.receiveShadow = true;
            scene.add(enemyMesh);

            const enemy = {
                mesh: enemyMesh,
                health: 75 + game.round * 5,
                maxHealth: 75 + game.round * 5,
                fireCooldown: THREE.MathUtils.randFloat(1.5, 2.5),
                patrolTimer: 0,
                targetPoint: new THREE.Vector3(),
                state: 'search',
                chaseSpeed: movementConfig.enemyChase,
                patrolSpeed: movementConfig.enemyPatrol
            };

            enemy.targetPoint.set(
                THREE.MathUtils.randFloatSpread(world.size * 0.6),
                0,
                THREE.MathUtils.randFloatSpread(world.size * 0.6)
            );

            enemies.push(enemy);
        }

        function shoot(fromEnemy = false, enemy = null) {
            if (fromEnemy) {
                const geometry = new THREE.SphereGeometry(0.12, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xff5533 });
                const bullet = new THREE.Mesh(geometry, material);
                scene.add(bullet);

                const direction = new THREE.Vector3();
                direction.subVectors(controls.getObject().position, enemy.mesh.position).normalize();
                direction.y = 0;
                direction.normalize();

                bullet.position.copy(enemy.mesh.position).add(new THREE.Vector3(0, 1.3, 0));
                enemyBullets.push({
                    mesh: bullet,
                    velocity: direction.multiplyScalar(enemyBulletSpeed),
                    life: 2.5
                });
                enemy.fireCooldown = THREE.MathUtils.randFloat(1.2, 2.2);
            } else {
                if (!player.alive || player.isReloading || player.ammo <= 0) return;

                const geometry = new THREE.SphereGeometry(0.09, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const bullet = new THREE.Mesh(geometry, material);
                bullet.castShadow = false;
                bullet.receiveShadow = false;
                scene.add(bullet);

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);

                muzzleFlash.getWorldPosition(muzzleWorldPosition);
                bullet.position.copy(muzzleWorldPosition);
                bullet.position.add(direction.clone().multiplyScalar(0.1));
                muzzleFlash.visible = true;
                setTimeout(() => (muzzleFlash.visible = false), 50);

                bullets.push({
                    mesh: bullet,
                    velocity: direction.multiplyScalar(bulletSpeed),
                    life: 2.2
                });

                player.ammo -= 1;
                updateAmmoDisplay();
                player.fireCooldown = 0.1;
            }
        }

        function reloadWeapon() {
            if (player.isReloading || player.ammo === player.maxAmmo || player.reserve <= 0) return;
            player.isReloading = true;
            player.reloadTimer = player.reloadTime;
        }

        function updateAmmoDisplay() {
            ammoEl.textContent = `${player.ammo} / ${player.reserve}`;
        }

        function damagePlayer(amount) {
            if (!player.alive) return;
            player.health = Math.max(0, player.health - amount);
            const healthRatio = player.health / 100;
            healthBarEl.style.width = `${healthRatio * 100}%`;
            overlayEl.style.background = 'rgba(255, 0, 0, 0.35)';
            setTimeout(() => {
                overlayEl.style.background = 'rgba(255,0,0,0)';
            }, 180);

            if (player.health <= 0) {
                handleGameOver();
            }
        }

        function handleGameOver() {
            player.alive = false;
            game.state = 'over';
            gameOverEl.style.display = 'grid';
            controls.unlock();
        }

        function removeEnemy(enemy, giveScore = true) {
            const index = enemies.indexOf(enemy);
            if (index !== -1) {
                scene.remove(enemy.mesh);
                enemies.splice(index, 1);
                if (giveScore) {
                    game.score += 10;
                    scoreEl.textContent = `Skor: ${game.score}`;
                }
                game.enemiesRemaining -= 1;
                enemiesEl.textContent = `Hayatta Kalan Düşman: ${Math.max(game.enemiesRemaining, 0)}`;
                if (game.enemiesRemaining <= 0 && game.spawnQueue <= 0 && enemies.length === 0) {
                    setTimeout(startNextRound, 2000);
                }
            }
        }

        function updatePlayer(delta) {
            if (!controls.isLocked) return;

            const sprinting = keyState['ShiftLeft'] || keyState['ShiftRight'];
            const moveSpeed = player.speed * (sprinting ? player.sprintMultiplier : 1);
            let moveForward = 0;
            let moveRight = 0;

            if (keyState['KeyW']) moveForward += 1;
            if (keyState['KeyS']) moveForward -= 1;
            if (keyState['KeyD']) moveRight += 1;
            if (keyState['KeyA']) moveRight -= 1;

            const moveLength = Math.hypot(moveForward, moveRight);
            if (moveLength > 0) {
                moveForward /= moveLength;
                moveRight /= moveLength;
            }

            const oldPosition = controls.getObject().position.clone();
            const distance = moveSpeed * delta;
            if (moveForward !== 0) controls.moveForward(moveForward * distance);
            if (moveRight !== 0) controls.moveRight(moveRight * distance);

            if (player.onGround && keyState['Space']) {
                player.velocity.y = player.jumpStrength;
                player.onGround = false;
            }

            player.velocity.y -= player.gravity * delta;
            controls.getObject().position.y += player.velocity.y * delta;

            if (controls.getObject().position.y < player.height) {
                player.velocity.y = 0;
                controls.getObject().position.y = player.height;
                player.onGround = true;
            } else if (player.velocity.y < 0) {
                player.onGround = false;
            }

            playerCollider.setFromCenterAndSize(controls.getObject().position, new THREE.Vector3(1, player.height, 1));

            const colliders = [...world.walls, ...world.obstacles];
            for (const collider of colliders) {
                tempBox.setFromObject(collider);
                if (playerCollider.intersectsBox(tempBox)) {
                    controls.getObject().position.copy(oldPosition);
                    player.velocity.y = 0;
                    player.onGround = true;
                    break;
                }
            }

            if (player.isReloading) {
                player.reloadTimer -= delta;
                if (player.reloadTimer <= 0) {
                    const needed = player.maxAmmo - player.ammo;
                    const toLoad = Math.min(needed, player.reserve);
                    player.ammo += toLoad;
                    player.reserve -= toLoad;
                    updateAmmoDisplay();
                    player.isReloading = false;
                }
            }
        }

        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i -= 1) {
                const bullet = bullets[i];
                bullet.mesh.position.addScaledVector(bullet.velocity, delta);
                bullet.life -= delta;

                if (bullet.life <= 0) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                    continue;
                }

                for (const wall of world.walls) {
                    tempBox.setFromObject(wall);
                    if (tempBox.containsPoint(bullet.mesh.position)) {
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);
                        break;
                    }
                }

                for (let j = enemies.length - 1; j >= 0; j -= 1) {
                    const enemy = enemies[j];
                    enemyCollider.setFromObject(enemy.mesh);
                    if (enemyCollider.containsPoint(bullet.mesh.position)) {
                        scene.remove(bullet.mesh);
                        bullets.splice(i, 1);
                        enemy.health -= 35;
                        const originalEmissive = enemy.mesh.material.emissive.clone();
                        enemy.mesh.material.emissive.set(0xff3333);
                        setTimeout(() => {
                            enemy.mesh.material.emissive.copy(originalEmissive);
                        }, 120);

                        if (enemy.health <= 0) {
                            removeEnemy(enemy);
                        }
                        break;
                    }
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i -= 1) {
                const bullet = enemyBullets[i];
                bullet.mesh.position.addScaledVector(bullet.velocity, delta);
                bullet.life -= delta;

                if (bullet.life <= 0) {
                    scene.remove(bullet.mesh);
                    enemyBullets.splice(i, 1);
                    continue;
                }

                playerCollider.setFromCenterAndSize(controls.getObject().position.clone(), new THREE.Vector3(1, player.height, 1));
                if (playerCollider.containsPoint(bullet.mesh.position)) {
                    damagePlayer(15);
                    scene.remove(bullet.mesh);
                    enemyBullets.splice(i, 1);
                    continue;
                }

                for (const wall of world.walls) {
                    tempBox.setFromObject(wall);
                    if (tempBox.containsPoint(bullet.mesh.position)) {
                        scene.remove(bullet.mesh);
                        enemyBullets.splice(i, 1);
                        break;
                    }
                }
            }
        }

        function updateEnemies(delta) {
            for (const enemy of enemies) {
                const playerPos = controls.getObject().position;
                const toPlayer = new THREE.Vector3().subVectors(playerPos, enemy.mesh.position);
                const distance = toPlayer.length();

                enemy.fireCooldown -= delta;
                enemy.patrolTimer -= delta;

                if (distance < 45) {
                    enemy.state = 'attack';
                    toPlayer.y = 0;
                    toPlayer.normalize();
                    enemy.mesh.lookAt(new THREE.Vector3().copy(enemy.mesh.position).add(toPlayer));

                    if (distance > 6) {
                        enemy.mesh.position.addScaledVector(toPlayer, delta * enemy.chaseSpeed);
                    }

                    if (enemy.fireCooldown <= 0) {
                        shoot(true, enemy);
                    }
                } else {
                    if (enemy.state !== 'patrol' || enemy.patrolTimer <= 0) {
                        enemy.state = 'patrol';
                        enemy.targetPoint.set(
                            THREE.MathUtils.randFloatSpread(world.size * 0.6),
                            0,
                            THREE.MathUtils.randFloatSpread(world.size * 0.6)
                        );
                        enemy.patrolTimer = THREE.MathUtils.randFloat(4, 7);
                    }

                    const moveDir = new THREE.Vector3().subVectors(enemy.targetPoint, enemy.mesh.position);
                    moveDir.y = 0;
                    const moveDist = moveDir.length();

                    if (moveDist > 1) {
                        moveDir.normalize();
                        enemy.mesh.position.addScaledVector(moveDir, delta * enemy.patrolSpeed);
                        enemy.mesh.lookAt(enemy.mesh.position.clone().add(moveDir));
                    }
                }

                tempBox.setFromObject(enemy.mesh);
                for (const wall of world.walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    if (tempBox.intersectsBox(wallBox)) {
                        enemy.mesh.position.addScaledVector(toPlayer.normalize().multiplyScalar(-1), delta * enemy.chaseSpeed);
                    }
                }
            }
        }

        function updateMinimap() {
            const ctx = minimapCtx;
            const size = minimapCanvas.width;
            const scale = size / world.size;

            ctx.clearRect(0, 0, size, size);

            ctx.fillStyle = 'rgba(10, 18, 28, 0.9)';
            ctx.fillRect(0, 0, size, size);

            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.strokeRect(2, 2, size - 4, size - 4);

            const playerPos = controls.getObject().position;

            function project(pos) {
                return {
                    x: size / 2 + pos.x * scale,
                    y: size / 2 + pos.z * scale
                };
            }

            ctx.fillStyle = '#50c8ff';
            const p = project(playerPos);
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff5c3b';
            enemies.forEach((enemy) => {
                const ep = project(enemy.mesh.position);
                ctx.beginPath();
                ctx.arc(ep.x, ep.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(0.05, clock.getDelta());

            if (player.fireCooldown > 0) {
                player.fireCooldown -= delta;
            }

            if (shooting && player.fireCooldown <= 0) {
                shoot(false);
            }

            if (game.state !== 'over') {
                updatePlayer(delta);
                updateEnemies(delta);
                updateBullets(delta);
                updateMinimap();

                if (game.state === 'spawning') {
                    game.spawnDelay -= delta;
                    if (game.spawnDelay <= 0 && game.spawnQueue > 0) {
                        spawnEnemy();
                        game.spawnQueue -= 1;
                        game.spawnDelay = THREE.MathUtils.randFloat(0.6, 1.2);
                    } else if (game.spawnQueue <= 0) {
                        game.state = 'inRound';
                    }
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        resetGame();
        animate();
    </script>
</body>
</html>
